//
// Autogenerated by Thrift Compiler (0.14.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//

import thrift = require('thrift');
import Thrift = thrift.Thrift;
import Q = thrift.Q;
import Int64 = require('node-int64');
import shared_ttypes = require('./shared_types');


import ttypes = require('./devicemanager_types');
import DeviceState = ttypes.DeviceState
import RepositoryType = ttypes.RepositoryType
import DEVICEMANAGER_ID = ttypes.DEVICEMANAGER_ID
import DeviceManagerError = ttypes.DeviceManagerError
import Device = ttypes.Device
import Repository = ttypes.Repository

/**
 *  
 * 
 */
declare class Client {
  #output: thrift.TTransport;
  #pClass: thrift.TProtocol;
  #_seqid: number;

  constructor(output: thrift.TTransport, pClass: { new(trans: thrift.TTransport): thrift.TProtocol });

  /**
   * * Gets a list of all known repositories for a given IAR toolchain id (e.g. 'arm')
   *  *
   * * @throws DeviceManagerError in case the repository list cannot be retrieved
   */
  getRepositoriesForToolchain(toolchainId: string): Q.Promise<Repository[]>;

  /**
   * * Gets a list of all known repositories for a given IAR toolchain id (e.g. 'arm')
   *  *
   * * @throws DeviceManagerError in case the repository list cannot be retrieved
   */
  getRepositoriesForToolchain(toolchainId: string, callback?: (error: ttypes.DeviceManagerError, response: Repository[])=>void): void;

  /**
   * * Gets a map of device tags to device definitions given a Repository
   * *
   * * @throws DeviceManagerError in case the list of devices for this repository's URI and toolchain cannot be retrieved.
   * * Clients calling this function should handle this exception according to the repository type.
   *  * For example, remote repositories can be subjected to timeout and other connection errors.
   */
  getDevicesForRepository(repository: Repository): Q.Promise<{ [k: string]: Device; }>;

  /**
   * * Gets a map of device tags to device definitions given a Repository
   * *
   * * @throws DeviceManagerError in case the list of devices for this repository's URI and toolchain cannot be retrieved.
   * * Clients calling this function should handle this exception according to the repository type.
   *  * For example, remote repositories can be subjected to timeout and other connection errors.
   */
  getDevicesForRepository(repository: Repository, callback?: (error: ttypes.DeviceManagerError, response: { [k: string]: Device; })=>void): void;

  /**
   * Add a Repository to the device manager
   * 
   * @throws DeviceManagerError if the repository definition is invalid or cannot be registered
   */
  addRepository(repository: Repository): Q.Promise<void>;

  /**
   * Add a Repository to the device manager
   * 
   * @throws DeviceManagerError if the repository definition is invalid or cannot be registered
   */
  addRepository(repository: Repository, callback?: (error: ttypes.DeviceManagerError, response: void)=>void): void;

  /**
   * Add a Repository to the device manager, using a local file path
   * 
   * @returns the Repository which was added to the device manager
   * @throws DeviceManagerError if the repository definition is invalid or cannot be registered
   */
  addRepositoryForLocalPath(localPath: string, toolchainId: string, displayName: string): Q.Promise<Repository>;

  /**
   * Add a Repository to the device manager, using a local file path
   * 
   * @returns the Repository which was added to the device manager
   * @throws DeviceManagerError if the repository definition is invalid or cannot be registered
   */
  addRepositoryForLocalPath(localPath: string, toolchainId: string, displayName: string, callback?: (error: ttypes.DeviceManagerError, response: Repository)=>void): void;

  /**
   * Remove a repository from the device manager for the given URI and toolchain.
   * 
   * This is a no-op if the repository has not been registered previously.
   */
  removeRepositoryForUri(uri: string, toolchainId: string): Q.Promise<void>;

  /**
   * Remove a repository from the device manager for the given URI and toolchain.
   * 
   * This is a no-op if the repository has not been registered previously.
   */
  removeRepositoryForUri(uri: string, toolchainId: string, callback?: (error: void, response: void)=>void): void;

  /**
   * Remove a repository from the device manager, accounting for its URI and toolchain.
   * 
   * This is a no-op if the repository has not been registered previously.
   */
  removeRepository(repo: Repository): Q.Promise<void>;

  /**
   * Remove a repository from the device manager, accounting for its URI and toolchain.
   * 
   * This is a no-op if the repository has not been registered previously.
   */
  removeRepository(repo: Repository, callback?: (error: void, response: void)=>void): void;

  /**
   * * Query the project manager for the currently loaded toolchains, and add
   * * repositories for each one of them.
   * *
   * * Currently this adds the $TOOLKIT_DIR$/config/devices folder for each toolchain
   * * if no additional metadata is found.
   * *
   * * TBD: toolchain metadata format to specify which repos should be added
   * 3
   */
  addRepositoriesFromToolchains(): Q.Promise<{ [k: string]: Repository[]; }>;

  /**
   * * Query the project manager for the currently loaded toolchains, and add
   * * repositories for each one of them.
   * *
   * * Currently this adds the $TOOLKIT_DIR$/config/devices folder for each toolchain
   * * if no additional metadata is found.
   * *
   * * TBD: toolchain metadata format to specify which repos should be added
   * 3
   */
  addRepositoriesFromToolchains(callback?: (error: void, response: { [k: string]: Repository[]; })=>void): void;
}

declare class Processor {
  #_handler: object;

  constructor(handler: object);
  process(input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_getRepositoriesForToolchain(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_getDevicesForRepository(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_addRepository(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_addRepositoryForLocalPath(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_removeRepositoryForUri(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_removeRepository(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_addRepositoriesFromToolchains(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
}
