//
// Autogenerated by Thrift Compiler (0.14.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
import thrift = require('thrift');
import Thrift = thrift.Thrift;
import Q = thrift.Q;
import Int64 = require('node-int64');
import shared_ttypes = require('./shared_types');



/**
 * Each type describes the role of a tool in a C/C++ project build
 */
declare enum ToolType {
  Compiler = 1,
  Assembler = 2,
  Linker = 3,
  Archiver = 4,
  Other = 5,
}

/**
 * Each type describes how a tool is invoked during a build (e.g. single input, multi input)
 */
declare enum InvocationType {
  SingleInput = 1,
  MultiInput = 2,
}

/**
 * Element types in a project tree
 */
declare enum NodeType {
  Invalid = 0,
  Group = 1,
  File = 2,
  ControlFile = 3,
  ExternBinary = 4,
  AuxExternBinary = 5,
}

/**
 * An option type describes which control should be used to manipulate the option in a GUI
 * 
 * Most of these currently match the class names in the SWTD option system, as that is the
 * only option type system which is widely used. However, DeviceSelection represents both
 * EditMenu and CMSIS Pack device selectors.
 * 
 */
declare enum OptionType {
  Check = 0,
  Edit = 1,
  EditB = 2,
  List = 3,
  Radio = 4,
  CheckList = 5,
  BuildActions = 6,
  DeviceSelection = 7,
  CMSISDevice = 8,
  CMakeSettings = 9,
}

declare enum BuildSequence {
  PreBuild = 0,
  PostBuild = 1,
}

/**
 * Enumeration describing different file sets
 */
declare enum FileCollectionType {
  ProjFiles = 0,
  ProjAndUserIncludeFiles = 1,
  ProjAndAllIncludeFiles = 2,
  WsFiles = 3,
  WsAndUserIncludeFiles = 4,
  WsAndAllIncludeFiles = 5,
}

/**
 * Desktop Path Platforms
 */
declare enum DesktopPathPlatform {
  Mfc = 0,
  Qt = 1,
}

declare enum DesktopPathSlavery {
  Master = 0,
  Slave = 1,
}

/**
 * Possible categories of user arg var settings
 */
declare enum UserArgVarCategory {
  kWorkspace = 0,
  kGlobal = 1,
}

declare class ProjectManagerError extends Thrift.TException {
  public description: string;

    constructor(args?: { description: string; });
  read(input: Object): void;
  write(input: Object): void;
}

/**
 * Defines a build tool, e.g. a compiler.
 * 
 * A build tool is uniquely identified by its ID, and declares a set of input
 * and output file extensions to specify which files it is able to transform.
 * 
 */
declare class ToolDefinition {
  public id: string;
  public name: string;
  public executableName: string;
  public inputExtensions: string[];
  public outputExtensions: string[];
  public hiddenOutputExtensions: string[];
  public toolType: ToolType;
  public invocationType: InvocationType;
  public extensionOverrides: string;

    constructor(args?: { id: string; name: string; executableName: string; inputExtensions: string[]; outputExtensions: string[]; hiddenOutputExtensions: string[]; toolType: ToolType; invocationType: InvocationType; extensionOverrides: string; });
  read(input: Object): void;
  write(input: Object): void;
}

/**
 * Defines a hardware target for which projects can be built for using one or more tools
 * (compiler, linker, etc.).
 */
declare class Toolchain {
  public id: string;
  public name: string;
  public tools: ToolDefinition[];
  public toolkitDir: string;
  public templatesDir: string;
  public isCMakeToolchain: boolean;

    constructor(args?: { id: string; name: string; tools: ToolDefinition[]; toolkitDir: string; templatesDir: string; isCMakeToolchain: boolean; });
  read(input: Object): void;
  write(input: Object): void;
}

/**
 * A build configuration represents a way to build a Project.
 * @see ProjectContext
 */
declare class Configuration {
  public name: string;
  public toolchainId: string;
  public isDebug: boolean;
  public isControlFileManaged: boolean;

    constructor(args?: { name: string; toolchainId: string; isDebug: boolean; isControlFileManaged: boolean; });
  read(input: Object): void;
  write(input: Object): void;
}

/**
 * Corresponds to a workspace on disk
 */
declare class WorkspaceContext {
  public filename: string;

    constructor(args?: { filename: string; });
  read(input: Object): void;
  write(input: Object): void;
}

/**
 * Corresponds to a project on disk.
 * 
 * This type is both copiable and serializable, as the project manager
 * will always try to reconstruct the project by its path.
 * Therefore it is desirable to copy context instances instead of
 * holding references or pointers to an existing context owned by
 * another class, which might disappear and crash the application.
 */
declare class ProjectContext {
  public filename: string;

    constructor(args?: { filename: string; });
  read(input: Object): void;
  write(input: Object): void;
}

/**
 * A view of an element in a project tree and its children. <p>
 *  This can be modified on the client side and is not persisted in the actual project
 *  until the backend is instructed to save this element.
 * 
 * @see ProjectManager.SetNodeByIndex()
 */
declare class Node {
  public name: string;
  public children: Node[];
  public type: NodeType;
  public path: string;
  public isMfcEnabled: boolean;
  public isExcludedFromBuild: boolean;
  public hasLocalSettings: boolean;
  public hasRelevantSettings: boolean;
  public childrenHaveLocalSettings: boolean;
  public isGenerated: boolean;
  public controlFilePlugins: string[];

    constructor(args?: { name: string; children: Node[]; type: NodeType; path: string; isMfcEnabled: boolean; isExcludedFromBuild: boolean; hasLocalSettings: boolean; hasRelevantSettings: boolean; childrenHaveLocalSettings: boolean; isGenerated: boolean; controlFilePlugins: string[]; });
  read(input: Object): void;
  write(input: Object): void;
}

/**
 * A build step, i.e. a command line that takes some input file(s) and produces
 * some output file(s).
 */
declare class BuildNode {
  public input: string[];
  public output: string[];
  public arguments: string[];
  public directory: string;
  public toolName: string;

    constructor(args?: { input: string[]; output: string[]; arguments: string[]; directory: string; toolName: string; });
  read(input: Object): void;
  write(input: Object): void;
}

/**
 * Properties of an option's element (e.g. list item, radio button, a checkbox in a check list)
 */
declare class OptionElementDescription {
  public id: string;
  public label: string;
  public enabled: boolean;
  public data: string;

    constructor(args?: { id: string; label: string; enabled: boolean; data: string; });
  read(input: Object): void;
  write(input: Object): void;
}

/**
 * Properties of an option
 */
declare class OptionDescription {
  public id: string;
  public value: string;
  public type: OptionType;
  public elements: OptionElementDescription[];
  public enabled: boolean;
  public visible: boolean;
  public canBeLocal: boolean;

    constructor(args?: { id: string; value: string; type: OptionType; elements: OptionElementDescription[]; enabled: boolean; visible: boolean; canBeLocal: boolean; });
  read(input: Object): void;
  write(input: Object): void;
}

/**
 * Associates a group of options under a single category.
 */
declare class OptionCategory {
  public id: string;
  public optionIds: string[];

    constructor(args?: { id: string; optionIds: string[]; });
  read(input: Object): void;
  write(input: Object): void;
}

/**
 * Input to builds.
 */
declare class BuildItem {
  public projectContext: ProjectContext;
  public configurationName: string;
  public nodePaths: string[];

    constructor(args?: { projectContext: ProjectContext; configurationName: string; nodePaths: string[]; });
  read(input: Object): void;
  write(input: Object): void;
}

declare class BatchBuildItem {
  public name: string;
  public buildItems: BuildItem[];

    constructor(args?: { name: string; buildItems: BuildItem[]; });
  read(input: Object): void;
  write(input: Object): void;
}

/**
 * Stores the result of a build, referring to the project that was built
 */
declare class BuildResult {
  public projectContext: ProjectContext;
  public buildOutput: string[];
  public succeded: boolean;

    constructor(args?: { projectContext: ProjectContext; buildOutput: string[]; succeded: boolean; });
  read(input: Object): void;
  write(input: Object): void;
}

/**
 * A simple representation of the control file plugins to use in GUI:s
 */
declare class ControlFilePlugin {
  public name: string;
  public filefilter: string;
  public isInternal: boolean;

    constructor(args?: { name: string; filefilter: string; isInternal: boolean; });
  read(input: Object): void;
  write(input: Object): void;
}

/**
 * Settings for user arg vars. Replaces PmUserArgVarModifier
 */
declare class UserArgVarInfo {
  public name: string;
  public value: string;
  public id: number;

    constructor(args?: { name: string; value: string; id: number; });
  read(input: Object): void;
  write(input: Object): void;
}

/**
 * Settings for user arg var groups
 */
declare class UserArgVarGroupInfo {
  public name: string;
  public active: boolean;
  public readOnly: boolean;
  public inherited: boolean;
  public category: UserArgVarCategory;
  public id: number;
  public variables: UserArgVarInfo[];

    constructor(args?: { name: string; active: boolean; readOnly: boolean; inherited: boolean; category: UserArgVarCategory; id: number; variables: UserArgVarInfo[]; });
  read(input: Object): void;
  write(input: Object): void;
}

/**
 * A build tool provided to the project manager by a client
 */
declare class ExternalTool {
  public name: string;
  public path: string;
  public arguments: string;
  public positionRegexp: string;
  public warningRegexp: string;
  public errorRegexp: string;

    constructor(args?: { name: string; path: string; arguments: string; positionRegexp: string; warningRegexp: string; errorRegexp: string; });
  read(input: Object): void;
  write(input: Object): void;
}

/**
 * Abstract description of the wizards available
 */
declare class WizardPlugin {
  public toolchainName: string;
  public displayName: string;
  public description: string;
  public requireSave: boolean;

    constructor(args?: { toolchainName: string; displayName: string; description: string; requireSave: boolean; });
  read(input: Object): void;
  write(input: Object): void;
}

declare var PROJECTMANAGER_ID: string;
